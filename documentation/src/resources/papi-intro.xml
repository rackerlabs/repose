<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book [
<!-- product name is likely to change; parameterize full name, abbreviated name, expanded name -->
<!ENTITY PRODNAME "Power API">
<!ENTITY PRODABBREV "PAPI">
<!ENTITY PRODEXPAND "Rackspace Cloud Power Application Program Interface (API)">
    <!-- Some useful entities borrowed from HTML -->
    <!ENTITY ndash  "&#x2013;">
    <!ENTITY mdash  "&#x2014;">
    <!ENTITY hellip "&#x2026;">

    <!-- Useful for describing APIs -->
    <!ENTITY GET    '<command xmlns="http://docbook.org/ns/docbook">GET</command>'>
    <!ENTITY PUT    '<command xmlns="http://docbook.org/ns/docbook">PUT</command>'>
    <!ENTITY POST   '<command xmlns="http://docbook.org/ns/docbook">POST</command>'>
    <!ENTITY DELETE '<command xmlns="http://docbook.org/ns/docbook">DELETE</command>'>

    <!ENTITY CHECK  '<inlinemediaobject xmlns="http://docbook.org/ns/docbook">
        <imageobject>
        <imagedata fileref="img/Check_mark_23x20_02.svg"
        format="SVG" scale="60"/>
        </imageobject>
        </inlinemediaobject>'>

    <!ENTITY ARROW  '<inlinemediaobject xmlns="http://docbook.org/ns/docbook">
        <imageobject>
        <imagedata fileref="img/Arrow_east.svg"
        format="SVG" scale="60"/>
        </imageobject>
        </inlinemediaobject>'>
]>
<!-- in BOOK below, add status="draft" to set watermark on cover and left margin -->
<book version="5.0" xmlns="http://docbook.org/ns/docbook"
      xmlns:xlink="http://www.w3.org/1999/xlink"
      xmlns:xi="http://www.w3.org/2001/XInclude"
      xmlns:svg="http://www.w3.org/2000/svg"
      xmlns:m="http://www.w3.org/1998/Math/MathML"
      xmlns:html="http://www.w3.org/1999/xhtml"
      xmlns:db="http://docbook.org/ns/docbook" >
    <?rax pdf.url="../../papi-intro.pdf"?>
    <title>&PRODNAME; Introduction</title>
    <!-- set watermark on cover and left margin 
        <?rax status.bar.text="CONFIDENTIAL"?>
    -->
    <?rax title.font.size="35px" subtitle.font.size="16px"?>
    <titleabbrev>&PRODABBREV; Introduction</titleabbrev>
    <info>
        <author>
            <personname>
                <firstname/>
                <surname/>
            </personname>
            <affiliation>
                <orgname>Rackspace Cloud</orgname>
            </affiliation>
        </author>
        <copyright>
            <year>2010</year>
            <year>2011</year>
            <holder>Rackspace US, Inc.</holder>
        </copyright>
        <releaseinfo>v0.9</releaseinfo>
        <productname>&PRODNAME;</productname>
        <pubdate>2011-09-24</pubdate>
        <legalnotice role="apache2">
            <annotation>
                <remark>Copyright details are filled in by the template.</remark>
            </annotation>
        </legalnotice>
        <abstract>
            <para>This document is intended for anyone seeking basic information about &PRODNAME;. </para>
        </abstract>
    </info>
    <chapter xml:id="Overview-d1e85">
        <title>Overview</title>
        <section xml:id="Purpose-d1e90">
            <title>Purpose of This Document</title>
            <para> The purpose of this Introduction is to answer several basic questions about
                &PRODNAME;: </para>
            <itemizedlist spacing="normal">
                <listitem>
                    <para>
                        <link linkend="Define-d1e365">What is &PRODNAME;?</link>
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <link linkend="Design-d1e665">How does &PRODNAME; work?</link>
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <link linkend="Try-d1e731">How can I try &PRODNAME;?</link>
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <link linkend="Available_Doc-d1e140">Where can I learn more about &PRODNAME;?</link>
                    </para>
                </listitem>
            </itemizedlist>   
        </section>
        <section xml:id="Document_Change_History-d1e102">
            <title>Document Change History</title>
            <para>This version of the Introduction replaces and obsoletes all previous versions. The
                most recent changes are described in the table below: </para>
            <informaltable rules="all">
                <thead>
                    <tr align="center">
                        <td colspan="1">Revision Date</td>
                        <td colspan="4">Summary of Changes</td>
                    </tr>
                </thead>
                <tbody>
                    <tr align="left">
                        <td colspan="1" align="center">Sep 26, 2011</td>
                        <td colspan="4" align="left">
                            <itemizedlist spacing="compact">
                                <listitem>
                                    <para>Initial release.</para>
                                </listitem>
                            </itemizedlist>
                        </td>
                    </tr>
                </tbody>
            </informaltable>
        </section>
        <xi:include href="chapters/available-doc.xml"/>
    </chapter>
    <chapter xml:id="Define-d1e365">
        <title>What is &PRODNAME;?</title>
        <annotation>
            <remark>
                Source for this chapter is https://wiki.mosso.com/display/CT/Cloud+Service+Bus
            </remark>
        </annotation>
        <para> 
            &PRODNAME; is a stack of reusable software components that can be leveraged by service developers to perform common API processing tasks.
            By using &PRODNAME;'s components rather than creating their own, service developers can focus on the unique features of their services.
        </para>
        <para> 
            &PRODNAME; can be used inside a service to perform API operations.
            It can also run on one or more separate servers as a proxy to one or more services.
        </para>
        <para> 
            Available &PRODNAME; components include:
        </para>
        <itemizedlist spacing="compact">
            <listitem>
                <para>
                    Client Authentication
                </para>
            </listitem>
            <listitem>
                <para>
                    Client Authorization
                </para>
            </listitem>
            <listitem>
                <para>
                    HTTP Logging
                </para>
            </listitem>
            <listitem>
                <para>
                    Rate Limiting
                </para>
            </listitem>
            <listitem>
                <para>
                    Versioning
                </para>
            </listitem>
        </itemizedlist>
        <para> 
            Additional &PRODNAME; components being designed or planned include:
        </para>
        <itemizedlist spacing="compact">
            <listitem>
                <para>
                    Content Negotiation
                </para>
            </listitem>
            <listitem>
                <para>
                    Content Normalization
                </para>
            </listitem>
            <listitem>
                <para>
                    Contract Scope Filter
                </para>
            </listitem>
            <listitem>
                <para>
                    Service Authentication
                </para>
            </listitem>
            <listitem>
                <para>
                    Translation
                </para>
            </listitem>
        </itemizedlist>
        <note>
            <para>
                See <xref linkend="Available_Doc-d1e140"></xref> for a list of documentation about these components.
            </para>
        </note>
    </chapter>
    <chapter xml:id="Design-d1e665">
        <title>How Does &PRODNAME; Work?</title>
        <annotation>
            <remark>
                Source for this chapter is https://wiki.mosso.com/display/CT/PAPI+Components+and+Enterprise+Integration+Patterns
            </remark>
        </annotation>
        <para>
            A good way to understand &PRODNAME; is to think of it as a platform that can be used to implement integration patterns. 
            For example, existing &PRODABBREV; components implement the following Enterprise Integration Patterns:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    <link linkend="Pattern_Pipes-d1e667">pipes and filters</link>
                </para>
            </listitem>
            <listitem>
                <para>
                    <link linkend="Pattern_Message-d1e669">message router</link>
                </para>
            </listitem>
            <listitem>
                <para>
                    <link linkend="Pattern_Normalizer-d1e663">normalizer</link>       
                </para>
            </listitem>
        </itemizedlist>
        <para> To learn more about these and other integration patterns, visit Enterprise
            Integration Patterns at <link xlink:href="http://www.eaipatterns.com/toc.html"
                >http://www.eaipatterns.com/toc.html</link>. </para>
        <section xml:id="Pattern_Pipes-d1e667">
            <title>Pattern: Pipes and Filters</title>
            <para>  
                The <firstterm>pipes and filters</firstterm> pattern describes a way of constructing a route by
                creating a chain of filters. Requests are passed through the chain so that one filter's output becomes the next filter's input.
                This pipeline structure is analogous to the UNIX <code>pipe</code> command. 
                The advantage
                of the pipeline approach is that it enables you to combine services, some of which
                can be external to the application, to create more complex
                forms of message processing. 
            </para>
            <para>
                &PRODNAME; components each provide their own filter; by assembling your choice of components into a filtered pipeline, 
                you create your custom implementation of &PRODNAME;.
            </para>
            <para>
                The <firstterm>content normalization filter</firstterm> is the first filter in the &PRODNAME; filter chain.
                Content normalization is used only for HTTP header filtering.
            </para>
            <para>
                The <firstterm>rate limiting service filter</firstterm> protects the origin service from being bombarded by client requests. 
                It accomplishes this by specifying limits for the number of times a given client may request a given resource. 
                This provides essential protection to any public-facing API. A client's current limits may include the client's absolute limits. 
                Absolute limits are specific to a service domain and are therefore only provided by the origin service.
            </para>
        </section>
        <section xml:id="Pattern_Message-d1e669">
            <title>Pattern: Message Router</title>
            <para>
                A <firstterm>message router</firstterm> is a type of filter that consumes messages from a single consumer endpoint 
                and then redirects them to the appropriate target endpoint, based on a specific decision criterion. 
                A message router is concerned only with redirecting messages; it does not modify the message content.
            </para>
            <para>
                Routing in &PRODNAME; is a two-step process. 
                For example, the versioning component tags a request with a header (<code>X-PP-OriginDestination</code>) before handing the request to the next component. 
                This header may be read by &PRODNAME;'s routing components to then facilitate routing to the correct origin service .
            </para>
            <para>
                By using a message router filter, the versioning component can facilitate routing but it does not perform routing.
                The versioning configuration defines version mappings;  
                based on those definitions, the versioning component attempts to bind to actual host entries within the power proxy system model.
            </para>
            <para>
                To facilitate routing, the versioning component will first read in all the elements from both the versioning configuration 
                and the power proxy system model configuration. 
                Then, based on the power proxy host id attribute (<code>pp-host-id</code>) provided in the versioning configuration, 
                the versioning component will link power proxy host entries to each version mapping.
             </para>
        </section>
        <section xml:id="Pattern_Normalizer-d1e663">
            <title>Pattern: Normalizer</title>
            <para>
                The <firstterm>normalizer</firstterm> pattern is used to process messages that are semantically equivalent but arrive in different formats. 
                The normalizer transforms the incoming messages into a common format.
            </para>
        </section>
        <section xml:id="Vocabulary-d1e100">
            <title>&PRODNAME; Vocabulary</title>
            <remark>
                Source for this chapter is https://wiki.mosso.com/display/CT/PAPI+Glossary
            </remark>
            <note>
                <para> Below, we have explained what we mean when we use some basic &PRODNAME;
                    terms. 
                    Terms not defined in this section are not unique to &PRODNAME; 
                    and are used in
                    industry-standard ways. 
                    Many such terms are defined in the sources listed in
                        <xref linkend="References-d1e994"/>. 
                </para>
            </note>
            <glossary>
                <title>&PRODNAME; Components</title>
                <para>
                    <emphasis>
                        Components described here may not yet be available; 
                        familiarity with their basic ideas will help you plan for future
                        uses of &PRODNAME;.
                    </emphasis>
                </para>
                <glossentry xml:id="Auth11N-d1e015">
                    <glossterm><emphasis role="bold">Auth 1.1 (N)</emphasis></glossterm>
                    <glossdef>
                        <para> Auth 1.1 (N) is a client-side authentication component supporting Auth 1.1. It
                            manages caches and tokens.</para>
                    </glossdef>
                </glossentry>
                <glossentry xml:id="Auth11Z-d1e020">
                    <glossterm><emphasis role="bold">Auth 1.1 (Z)</emphasis></glossterm>
                    <glossdef>
                        <para> Auth 1.1 (Z) is a client-side authorization component supporting Auth 1.1.  It simply
                            checks that this endpoint is in the endpoint. </para>
                    </glossdef>
                </glossentry>
                <glossentry xml:id="Basic_Auth-d1e010">
                    <glossterm><emphasis role="bold">Basic Auth</emphasis></glossterm>
                    <glossdef>
                        <para> The basic auth component is a service-side authentication component supporting Auth 1.1. It manages
                            caches and tokens. </para>
                    </glossdef>
                </glossentry>
                <glossentry xml:id="Contract_Scope-d1e045">
                    <glossterm><emphasis role="bold">Contract Scope</emphasis></glossterm>
                    <glossdef>
                        <para> Given a WADL, the contract scope conponent ensures that all requests
                            adhere to the WADL. </para>
                    </glossdef>
                </glossentry>
                <glossentry xml:id="IdMN-d1e050">
                    <glossterm><emphasis role="bold">IdM (N)</emphasis></glossterm>
                    <glossdef>
                        <para> The IdM (N) component is like the Auth 1.1 (N) component but
                            integrates directly with IdM (Auth 1.1.1).</para>
                    </glossdef>
                </glossentry>
                <glossentry xml:id="Normalization1-d1e040">
                    <glossterm><emphasis role="bold">Normalization</emphasis></glossterm>
                    <glossdef>
                        <para> The normalization component normalizes requests so that requests with
                            similar meaning are formatted consistently. Phase 1 reduces redundancy
                            in headers and XML but doesn’t handle content compression. Phase 2 adds
                            gzip support. </para>
                    </glossdef>
                </glossentry>
                <glossentry xml:id="Rate_Limiting-d1e025">
                    <glossterm><emphasis role="bold">Rate Limiting</emphasis></glossterm>
                    <glossdef>
                        <para> The rate limiting component manages rate limits according to limit group. It allows the backend to define
                            absolute limits. It also handles backoff errors, which are queryable. </para>
                    </glossdef>
                </glossentry>
                <glossentry xml:id="Service_Auth-d1e005">
                    <glossterm><emphasis role="bold">Service Auth</emphasis></glossterm>
                    <glossdef>
                        <para>
                            The service authentication component allows &PRODNAME; to authenticate against a service.
                            It works with a
                            service-side authentication component that selects the authentication scheme.
                        </para>
                    </glossdef>
                </glossentry>
                <glossentry xml:id="Translation1-d1e035">
                    <glossterm><emphasis role="bold">Translation</emphasis></glossterm>
                    <glossdef>
                        <para> The translation component allows conversion of MIME types. Phase 1
                            supports conversion by simply doing enough translation for other
                            components. Phase 2 allows translation of MIME types as service inputs,
                            XSLTs, and E4X.</para>
                    </glossdef>
                </glossentry>
                <glossentry xml:id="Versioning-d1e030">
                    <glossterm><emphasis role="bold">Versioning</emphasis></glossterm>
                    <glossdef>
                        <para> The versioning component describes the current version and any
                            available versions. It allows choosing versions by URI or MIME type; it
                            supports permalinks and multiple choices.</para>
                    </glossdef>
                </glossentry>
            </glossary>
            <glossary>
                <title>&PRODNAME; Internals</title>
                <para>
                    <emphasis>
                        These are not &PRODNAME; components but
                        are essential to the structure of &PRODNAME;.
                    </emphasis>
                </para>
                <glossentry xml:id="Message_Service-d1e065">
                    <glossterm><emphasis role="bold">Message Service</emphasis></glossterm>
                    <glossdef>
                        <para> The message service allows customization of messages and error
                            conditions so that &PRODNAME; never violates a service contract. </para>
                    </glossdef>
                </glossentry>
                <glossentry xml:id="Power_Filter-d1e070">
                    <glossterm><emphasis role="bold">Power Filter</emphasis></glossterm>
                    <glossdef>
                        <para>
                            The power filter is responsible for loading all other components.
                            Phase 1 understands config files, component EARs, and more.
                            Phase 2 adds PAIGE support, 
                            support for components moving between containers,
                            and support for components adding containers dynamically.
                        </para>
                    </glossdef>
                </glossentry>
                <glossentry xml:id="Root-d1e080">
                    <glossterm><emphasis role="bold">Root.WAR</emphasis></glossterm>
                    <glossdef>
                        <para>
                            Root.WAR is a deployment artifact that launches &PRODNAME; in an application
                            server without requiring direct integration with source code.
                        </para>
                    </glossdef>
                    <glossdef>
                        <para> </para>
                    </glossdef>
                </glossentry>
            </glossary>
            <glossary>
                <title>Other Key Ideas</title>
                <para>
                    <emphasis>
                        Understanding these ideas will help you follow the explanations and examples in &PRODNAME; documentation and more fully appreciate the possibilities of &PRODNAME;.
                    </emphasis>
                </para>
                <glossentry xml:id="Artifact-d1e085">
                    <glossterm><emphasis role="bold">Artifact</emphasis></glossterm>
                    <glossdef>
                        <para>An artifact may be a bundle of one or more components.</para>
                    </glossdef>
                </glossentry>
                <glossentry xml:id="Filter-d1e090">
                    <glossterm><emphasis role="bold">Filter</emphasis></glossterm>
                    <glossdef>
                        <para> A filter accepts incoming data, applies a specific kind of
                            processing, and passes the data along. A chain of filters can be
                            assembled into a pipeline. </para>
                    </glossdef>
                </glossentry>
                <glossentry xml:id="Router-d1e095">
                    <glossterm><emphasis role="bold">Message Router</emphasis></glossterm>
                    <glossdef>
                        <para>  A message router is a type of filter that consumes messages from a
                            single consumer endpoint and then redirects them to the appropriate
                            target endpoint, based on a specific decision criterion.  </para>
                    </glossdef>
                </glossentry>
                <glossentry xml:id="Origin-d1e100">
                    <glossterm><emphasis role="bold">Origin Service</emphasis></glossterm>
                    <glossdef>
                        <para>  The origin service is the source of all data processed by &PRODNAME;.  </para>
                    </glossdef>
                </glossentry>
                <glossentry xml:id="Pluggable-d1e105">
                    <glossterm><emphasis role="bold">Pluggable</emphasis></glossterm>
                    <glossdef>
                        <para>  A pluggable component can be installed or deinstalled without affecting the remaining components.  </para>
                    </glossdef>
                </glossentry>
                <glossentry xml:id="Service_Versions-d1e110">
                    <glossterm><emphasis role="bold">Service Versions Catalog</emphasis></glossterm>
                    <glossdef>
                        <para>  The service versions catalog lists all available versions.  </para>
                    </glossdef>
                </glossentry>
                <glossentry xml:id="System_Model-d1e115">
                    <glossterm><emphasis role="bold">System Model</emphasis></glossterm>
                    <glossdef>
                        <para>  The system model defines the entire cluster.  </para>
                    </glossdef>
                </glossentry>
            </glossary>    
        </section>
    </chapter>
    <chapter xml:id="Try-d1e731">
        <title>How Can I Try &PRODNAME;?</title>
        <annotation>
            <remark>
                Source for this chapter is https://wiki.mosso.com/display/CT/Deployment
            </remark>
        </annotation>
        <para>
            &PRODNAME; is distributed as a filter bundle, containing all available components. 
            You can choose which components to implement in your configuration.            
        </para>
        <figure xml:id="Filter-Bundle">
            <title>Multiple &PRODNAME; Components in Filter Bundle</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="figures/papi-intro-filterBundle.png" format="PNG" align="center"/>
                </imageobject>
            </mediaobject>
        </figure>
        <para>
            You can edit your <code>power-proxy.xml</code> to identify &PRODNAME; components to be loaded into the Power Proxy filter.
            You can configure the Power Proxy to use one or multiple &PRODNAME; components as additional filters, as shown below.
        </para>
        <figure xml:id="Power-Proxy">
            <title>Loading Multiple &PRODNAME; Components into Power Proxy</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="figures/papi-intro-powerproxy.png" format="PNG" align="center"/>
                </imageobject>
            </mediaobject>
        </figure>
        <para>
            &PRODNAME;'s components may be integrated with other services in several ways, including:
        </para> 
        <itemizedlist spacing="compact">
            <listitem>
                <para>
                    <link linkend="Embedded-d1e111">Embedded</link>
                </para>
            </listitem>
            <listitem>
                <para>
                    <link linkend="Root-d1e222">Root.WAR</link>
                </para>
            </listitem>
            <listitem>
                <para>
                    <link linkend="Valve-d1e333">Valve</link>
                    Valve
                </para>
            </listitem>
            <listitem>
                <para>
                    <link linkend="ProxyServer-d1e444">Proxy Server</link>
                </para>
            </listitem>
            <listitem>
                <para>
                    <link linkend="ProxyCluster-d1e555">Proxy Cluster</link>
                </para>
            </listitem>
        </itemizedlist>   
        <section xml:id="Embedded-d1e111">
            <title>Deployment Method: Embedded</title>
            <warning>
                <para> 
                    Early adopters of &PRODNAME; used this method. 
                    If you are developing a new service, do not use Embedded deployment.
                    This method will be deprecated soon.
                </para>
            </warning>
            <para>
                <firstterm>Embedded</firstterm> deployment means that the Power Filter is embedded in a service's WAR. 
                The service's host must also host all of the &PRODNAME; components in the same app container.
                Artifacts are loaded from the &PRODABBREV; filter bundle into the Power Filter.
                Requests pass through the Power Filter before continuing to the service-specific filters.
                The servlet container may be Tomcat, Jetty, GlassFish, or similar products.
            </para>
            <figure xml:id="Embed-d1e112">
                <title>Deployment by Embedding into WAR</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="figures/papi-intro-deploy-embedded.png" format="PNG" align="center"/>
                    </imageobject>
                </mediaobject>
            </figure>
            <para>
                To use this deployment method, configure <code>power-proxy.xml</code> as follows:
            </para>
            <example>
                <title>Configuring power-proxy.xml for Embedded Deployment</title>
                <programlisting language="xml">
<xi:include href="samples/papi-deploy-embedded.xml" parse="text"/>
                    </programlisting>
            </example>
        </section>
        <section xml:id="Root-d1e222">
            <title>Deployment Method: Root.WAR</title>
            <para> In <firstterm>Root.War</firstterm> deployment, the <code>root.war</code> supplied by &PRODNAME; replaces
                the root component of the servlet container. The servlet container may be Tomcat,
                Jetty, GlassFish, or similar products. </para>
            <note>
                <para>
                    This deployment method is discussed in more detail in the Root.WAR Deployment Handbook.
                </para>
            </note>    
            <figure xml:id="Root-Replace-d1e111">
                <title>Deployment by Replacing the Root Component</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="figures/papi-intro-deploy-root.png" format="PNG" align="center"/>
                    </imageobject>
                </mediaobject>
            </figure>
            <example>
                <title>Configuring power-proxy.xml for Root.WAR Deployment</title>
                <programlisting language="xml">
<xi:include href="samples/papi-deploy-root.xml" parse="text"/>
                    </programlisting>
            </example>
        </section>
        <section xml:id="Valve-d1e333">
            <title>Deployment Method: Valve</title>
            <para>
                In <firstterm>Valve</firstterm> deployment, Power API is in an external servlet container and acts as a second client, 
                replicating each client request. 
                A client sends a request to Valve, then Valve sends the request to Power Filter to processes the request. 
                Valve also sends the modified request to the origin service, which may be a Python service. 
                The origin service sends a response to Valve, which passes that response back to the client.
            </para>
            <figure xml:id="Valve-d1e334">
                <title>Deployment as Client Replica</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="figures/papi-intro-deploy-valve.png" format="PNG" align="center"/>
                    </imageobject>
                </mediaobject>
            </figure>
        </section>
        <section xml:id="ProxyServer-d1e444">
            <title>Deployment Method: Proxy Server</title>
            <para>
                In <firstterm>Proxy Server</firstterm> deployment, &PRODNAME; is in an external servlet container. 
                This allows host-level routing over the network, so a non-Java service can take advantage of &PRODABBREV; features.
            </para>
            <figure xml:id="ProxyServer-d1e445">
                <title>Deployment as External Servlet Container</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="figures/papi-intro-deploy-proxyServer.png" format="PNG" align="center"/>
                    </imageobject>
                </mediaobject>
            </figure>
            <example>
                <title>Configuring power-proxy.xml for Proxy Server Deployment</title>
                <programlisting language="xml">
<xi:include href="samples/papi-deploy-proxyServer.xml" parse="text"/>
                    </programlisting>
            </example>
        </section>
        <section xml:id="ProxyCluster-d1e555">
            <title>Deployment Method: Proxy Cluster</title>
            <para>  
                Using <firstterm>Proxy Cluster</firstterm> deployment, &PRODNAME; may be scaled across multiple hosts.
                Auto-balance caching between the cluster's nodes will occur on
                the basis of resources and requests. 
                This allows faster processing. 
            </para>
            <note>
                <para>
                    Only the Rate Limiting component is able to take advantage of auto-balance caching's performance improvement.
                </para>
            </note>
            <figure xml:id="ProxyCluster-d1e556">
                <title>Deployment Across Multiple Hosts</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="figures/papi-intro-deploy-proxyCluster.png" format="PNG" align="center"/>
                    </imageobject>
                </mediaobject>
            </figure>
            <example>
                <title>Configuring power-proxy.xml for Proxy Cluster Deployment</title>
                <programlisting language="xml">
<xi:include href="samples/papi-deploy-proxyCluster.xml" parse="text"/>
                    </programlisting>
            </example>
        </section>
    </chapter>
    <xi:include href="chapters/afterword.xml"/>
</book>