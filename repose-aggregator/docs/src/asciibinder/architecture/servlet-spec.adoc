= Servlet Specification

The https://javaee.github.io/servlet-spec/[Java Servlet Specification] is a document that details the design and API of a Java-based system that can respond to requests.
To learn more about the specification itself, visit the link near the start of this paragraph.

*Repose* is built on top of the servlet specification.
However, *Repose* also constrains the specification in certain ways.
For example, *Repose* can only service HTTP requests.

To understand the architecture of *Repose*, it is vital that one understands the servlet specification.
Currently, *Repose* complies with version 3.0 of the specification.

== Filter
The `ReposeFilter` class implements the `Filter` API and is the only filter in the base containers `FilterChain`.
It uses the `ReposeFilterLoader` class to load the `FilterContext` 's that are passed to the `ReposeFilterChain`.

Before calling into the Repose Filter Chain, it enhances the request from the client with a unique Transaction ID, if one is not already present, and starts a span with the <<../services/open-tracing.adoc#,OpenTracing Service>>.
When the Repose Filter Chain completes, the OpenTracing span is closed, the Via header is updated on the response, and the <<../services/metrics.adoc#,Metrics Service>> is updated.

== Filter Chain

The `ReposeFilterChain` class implements the `FilterChain` API, and is responsible for the coordination between filters.
That coordination includes things like dynamic determination of whether or not a filter should process a request or response, debug logging, and metrics gathering.
To learn more about this component, visit the <<filter-chain.adoc#,filter chain documentation page>>.

== Servlet

The `ReposeRoutingServlet` class implements the `Servlet` API and is registered with the servlet container.
It is responsible for routing the HTTP request from *Repose* to the origin service after the filter chain has finished processing the request.

This servlet uses the configuration information stored in the <<system-model.adoc#,System Model>> to determine what destinations are available.
Routing to an app on the same host but in another container or environment is easily configured in a generic way.
There is also a way to route to another *Repose* cluster defined in the <<system-model.adoc#,System Model>> using a basic built in Round Robin algorithm.

Even though Cluster Routing is possible, the complexity and inflexibility make its use viable in only the most specific situations.
The Round Robin routing does not do any health checks and will route to unhealthy nodes.
These are great options to have available for testing and early prototyping, but are not recommended for production.

The preferred deployment strategy is to put a repose node as a side-car proxy on the same host as the origin service in a 1 to 1 fashion.
If *Repose* needs to horizontally scale at a different rate from the origin service, then putting an external load balancer as the destination is the safer option.
