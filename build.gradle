buildscript {
    repositories {
        mavenCentral()
        jcenter()
        maven {
            url "https://plugins.gradle.org/m2/"
        }
    }

    dependencies {
        classpath 'gradle.plugin.org.unbroken-dome.gradle-plugins:gradle-testsets-plugin:1.4.2'
        classpath 'com.netflix.nebula:nebula-dependency-recommender:4.3.0'
        classpath 'gradle.plugin.org.openrepose:gradle-jaxb-plugin:2.5.0'
        classpath 'gradle.plugin.org.scoverage:gradle-scoverage:2.1.0'
        classpath 'com.github.jengelman.gradle.plugins:shadow:2.0.2'
        classpath 'org.github.ngbinh.scalastyle:gradle-scalastyle-plugin_2.11:1.0.1'
        classpath 'gradle.plugin.nl.javadude.gradle.plugins:license-gradle-plugin:0.13.1'
        classpath 'com.netflix.nebula:nebula-publishing-plugin:5.1.5'
        classpath 'com.netflix.nebula:gradle-git-scm-plugin:3.0.1'
        classpath 'com.netflix.nebula:gradle-ospackage-plugin:4.5.1'
        classpath 'org.ajoberstar:gradle-git:1.7.2'
        classpath 'com.bmuschko:gradle-docker-plugin:3.2.1'
        classpath 'gradle.plugin.org.openrepose:gradle-linkchecker-plugin:1.0.0'
        classpath 'gradle.plugin.io.github.http-builder-ng:http-plugin:0.1.1'
        classpath 'org.owasp:dependency-check-gradle:5.2.2'
    }
}

import groovyx.net.http.ContentTypes
import io.github.httpbuilderng.http.HttpTask

import static groovyx.net.http.NativeHandlers.Encoders

apply plugin: 'nebula.gradle-git-scm'
apply plugin: 'io.github.http-builder-ng.http-plugin'

ext {
    reposeCodename = "Falco"
    scalaMajor = '2'
    scalaMinor = '12'
    scalaPatch = '8'
    scalaMajDotMin = "$scalaMajor.$scalaMinor"
}

configurations {
    debBundle
    rpmBundle
}

dependencies {
    debBundle project(path: ':repose-aggregator:artifacts:cli-utils', configuration: 'deb')
    debBundle project(path: ':repose-aggregator:artifacts:valve', configuration: 'deb')
    debBundle project(path: ':repose-aggregator:artifacts:filter-bundle', configuration: 'deb')
    debBundle project(path: ':repose-aggregator:artifacts:extensions-filter-bundle', configuration: 'deb')
    debBundle project(path: ':repose-aggregator:artifacts:experimental-filter-bundle', configuration: 'deb')

    rpmBundle project(path: ':repose-aggregator:artifacts:cli-utils', configuration: 'rpm')
    rpmBundle project(path: ':repose-aggregator:artifacts:valve', configuration: 'rpm')
    rpmBundle project(path: ':repose-aggregator:artifacts:filter-bundle', configuration: 'rpm')
    rpmBundle project(path: ':repose-aggregator:artifacts:extensions-filter-bundle', configuration: 'rpm')
    rpmBundle project(path: ':repose-aggregator:artifacts:experimental-filter-bundle', configuration: 'rpm')
}

task('buildAll', description: 'Builds all the sub-projects.', group: 'release')

task('tagVersion', description: 'Tag the repository with the current version.', group: 'release', dependsOn: [buildAll]) {
    doLast {
        scmFactory.create().tag(version)
    }
}

//This populates the version number so that jenkins can grab it and send it on to the release verification job
task('exportVersion', description: 'Write the current build version out to a properties file.') {
    doLast {
        file("$rootDir/repose-aggregator/build/release-version.properties").text = 'RELEASE_VERSION=' + version + System.lineSeparator()
    }
}

task('publishToPackageRepo', type: HttpTask, group: 'publishing') {
    description 'Publishes the DEB and RPM packages to the package repository'
    dependsOn configurations.debBundle, configurations.rpmBundle, buildAll

    config {
        if (!project.hasProperty('nexus.openrepose.username')) {
            throw new GradleException('The "nexus.openrepose.username" property is required')
        }
        if (!project.hasProperty('nexus.openrepose.password')) {
            throw new GradleException('The "nexus.openrepose.password" property is required')
        }

        request.uri = 'https://nexus.openrepose.org'
        request.auth.basic getProperty('nexus.openrepose.username') as String, getProperty('nexus.openrepose.password') as String
        request.contentType = ContentTypes.BINARY[0]
        request.encoder ContentTypes.BINARY[0], Encoders.&binary

        // The requests are configured here (inside of the config closure) so that they are evaluated and
        // configured during the execution build phase rather than the configuration build phase.
        // This allows us to dynamically create requests to upload files that are not determined until after the
        // configuration phase for certain projects without having to dictate evaluation order between the projects.

        // PUT the rpm packages in the Nexus Yum repository
        configurations.rpmBundle.files.each { rpmFile ->
            put {
                request.uri.path = "/repository/el/${rpmFile.name}"
                request.body = rpmFile.bytes

                response.success {
                    logger.lifecycle 'Successfully uploaded {}', rpmFile.name
                }
            }
        }

        // POST the deb packages in the Nexus APT repository
        configurations.debBundle.files.each { debFile ->
            post {
                request.uri.path = "/repository/debian/"
                request.body = debFile.bytes

                response.success {
                    logger.lifecycle 'Successfully uploaded {}', debFile.name
                }
            }
        }
    }
}

task('release', description: 'Release the project and publish to all repos.', group: 'release', dependsOn: [exportVersion, tagVersion, publishToPackageRepo])

allprojects {
    group = 'org.openrepose'
    def baseVersion = '9.1.0.0'
    version = project.hasProperty('release') ? baseVersion : "$baseVersion~SNAPSHOT"

    apply plugin: 'idea'
    apply plugin: 'nebula.dependency-recommender'


    repositories {
        mavenCentral()
        maven {
            url "https://maven.research.rackspacecloud.com/content/groups/aggregate/"
        }
        maven {
            url 'https://build.shibboleth.net/nexus/content/repositories/releases'
        }
    }

    ext {
        docsHome = "http://www.openrepose.org/versions/$version/index.html".toString()
    }
}

subprojects {

    apply plugin: 'java'
    apply plugin: 'groovy'
    apply plugin: 'scala'
    apply plugin: 'org.unbroken-dome.test-sets'
    apply plugin: 'org.openrepose.gradle.plugins.jaxb'
    apply plugin: 'checkstyle'
    apply plugin: 'codenarc'
    apply plugin: 'scalaStyle'
    apply plugin: 'com.github.hierynomus.license'
    apply plugin: 'jacoco'
    apply plugin: 'nebula.maven-publish'
    apply plugin: 'signing'
    apply plugin: 'org.scoverage'
    apply plugin: 'org.owasp.dependencycheck'

    dependencies {
        jaxb "com.sun.xml.bind:jaxb-xjc"
        jaxb "com.sun.xml.bind:jaxb-impl"
        jaxb "javax.xml.bind:jaxb-api"
        jaxb "org.jvnet.jaxb2_commons:jaxb2-basics-ant"

        scoverage "org.scoverage:scalac-scoverage-plugin_$scalaMajDotMin:1.4.0"
        scoverage "org.scoverage:scalac-scoverage-runtime_$scalaMajDotMin:1.4.0"

    }

    testSets {
        integrationTest
    }

    check.dependsOn integrationTest
    integrationTest.mustRunAfter test

    sourceCompatibility = 1.8
    targetCompatibility = 1.8

    task transformXSDs() {
        description "Runs xml through an xslt transform"
        ext.outputDir = "$buildDir/src/generated-xsd"
        def xsltFile = "$rootDir/repose-aggregator/src/config/xsl/remove-1.1-elements.xsl"
        def schemaBaseDir = "$projectDir/src/main/resources/META-INF/schema"

        //If they set a property for the jaxbXSLT file override our default
        if (project.hasProperty('jaxbXsltFile')) {
            xsltFile = project.jaxbXsltFile
        }

        if (project.hasProperty('jaxbSchemaBase')) {
            schemaBaseDir = project.jaxbSchemaBase
        }

        inputs.files(
            fileTree(dir: schemaBaseDir, includes: ["**/*.xsd", "**/*.xjb"]),
            file(xsltFile)
        )
        outputs.dir outputDir

        doLast {
            file(outputDir).mkdirs()

            //Find all XSDs in the src/main/resources/META-INF.schema
            if (file(xsltFile).exists() && file(schemaBaseDir).exists()) {
                logger.info("Transforming Schemas")
                ant.xslt(
                    extension: '.xsd',
                    basedir: schemaBaseDir,
                    includes: "**/*.xsd",
                    excludes: "**/system-model.xsd",
                    style: xsltFile,
                    destdir: "${outputDir}"
                )
            } else {
                logger.info("NOT Transforming Schemas")
                copy {
                    from schemaBaseDir
                    into outputDir
                    include "**/*.xsd"
                    exclude "**/examples"
                }
            }

            //Copy over any bindings.xjb into their appropriate directories
            logger.info("Copying xjb's")
            copy {
                from schemaBaseDir
                into outputDir
                include "**/*.xjb"
                exclude "**/examples"
            }
        }
    }

    def generatedDir = "${buildDir}/src/generated-sources"

    jaxb {
        xsdDir = transformXSDs.outputDir
        bindingsDir = transformXSDs.outputDir
        xjc {
            destinationDir = generatedDir
            generateEpisodeFiles = false
        }
    }

    xjc.dependsOn transformXSDs

    sourceSets {
        generated {
            java {
                srcDirs += generatedDir
            }
        }
        main {
            compileClasspath += files([sourceSets.generated.java.outputDir])
            runtimeClasspath += files([sourceSets.generated.java.outputDir])
            java {
                exclude '**/*.jaxb'
                exclude '**/README'
            }
        }
        test {
            compileClasspath += configurations.compileOnly
            runtimeClasspath += configurations.compileOnly
            compileClasspath += files([sourceSets.generated.java.outputDir])
            runtimeClasspath += files([sourceSets.generated.java.outputDir])
        }
        integrationTest {
            compileClasspath += configurations.compileOnly
            runtimeClasspath += configurations.compileOnly
            compileClasspath += files([sourceSets.generated.java.outputDir])
            runtimeClasspath += files([sourceSets.generated.java.outputDir])
        }
        scoverage {
            compileClasspath += configurations.compileOnly
            runtimeClasspath += configurations.compileOnly
            compileClasspath += files([sourceSets.generated.java.outputDir, sourceSets.main.java.outputDir])
            runtimeClasspath += files([sourceSets.generated.java.outputDir, sourceSets.main.java.outputDir, sourceSets.test.groovy.outputDir])
        }
        testScoverage {
            compileClasspath += configurations.compileOnly
            runtimeClasspath += configurations.compileOnly
            compileClasspath += files([sourceSets.generated.java.outputDir, sourceSets.main.java.outputDir])
            runtimeClasspath += files([sourceSets.generated.java.outputDir,
                                       sourceSets.main.java.outputDir,
                                       sourceSets.main.groovy.outputDir,
                                       sourceSets.test.groovy.outputDir,
                                       file("${project.buildDir}/resources/scoverage/")
            ])
        }
    }

    compileJava.dependsOn compileGeneratedJava
    compileScala.dependsOn compileGeneratedJava
    compileIntegrationTestGroovy.dependsOn compileGeneratedJava
    testScoverage.dependsOn compileTestGroovy

    [JavaCompile, ScalaCompile, GroovyCompile].collect { type ->
        tasks.withType(type) {
            dependsOn('xjc')
        }
    }

    configurations {
        compile.exclude group: 'commons-logging', module: 'commons-logging'

        testCompile.exclude group: 'xerces', module: 'xerces'
    }

    checkstyle {
        configFile = file("$rootDir/repose-aggregator/src/config/styles/checkstyle.xml")
        sourceSets = sourceSets.matching {it.name != 'generated' && it.name != 'scoverage' && it.name != 'testScoverage'}
    }

    codenarc {
        configFile = file("$rootDir/repose-aggregator/src/config/styles/codenarc.xml")
        sourceSets = sourceSets.matching {it.name != 'generated' && it.name != 'scoverage' && it.name != 'testScoverage'}
        toolVersion = "1.0"
    }

    //todo: write a good one of these plugins, because this is garbage
    scalaStyle {
        configLocation = "$rootDir/repose-aggregator/src/config/styles/scalastyle_config.xml"
        includeTestSourceDirectory = true
        source = "src/main/scala"
        testSource = "src/test/scala"
        failOnWarning = true
        quiet = true
    }

    check.dependsOn scalaStyle

    license {
        header file("$rootDir/repose-aggregator/src/config/license/LICENSE.txt")
        mapping {
            scala = 'SLASHSTAR_STYLE'
        }
        exclude "**/*.cfg.xml"
        exclude "**/log4j2*.xml"
        sourceSets = sourceSets.matching {it.name != 'generated' && it.name != 'scoverage' && it.name != 'testScoverage'}
    }

    //todo: for some reason jacoco freaks when we do clean and build together
    jacoco {
        toolVersion = "0.8.1"
    }

    jacocoTestReport {
        afterEvaluate {
            sourceDirectories = files([sourceSets.main.java.srcDirs, sourceSets.generated.java.srcDirs])
            classDirectories = files([sourceSets.main.java.outputDir, sourceSets.generated.java.outputDir])
            classDirectories = files(classDirectories.files.collect { classDirectory ->
                fileTree(dir: classDirectory, excludes: ['**/ObjectFactory.class'])
            })
        }
    }

    test {
        jacoco {
            destinationFile = file("$buildDir/jacoco/jacocoTest.exec")
        }
    }

    integrationTest {
        jacoco {
            destinationFile = file("$buildDir/jacoco/jacocoIntegrationTest.exec")
        }
        systemProperty 'jacocoArguments', jacoco.getAsJvmArg()

        if (project.hasProperty('javaArguments')) {
            systemProperty 'javaArguments', project.getProperty('javaArguments')
        }
    }

    dependencyCheck {
        scanConfigurations = [
            'compile',
            'implementation',
            'compileOnly',
            'compileClasspath',
            'runtime',
            'runtimeOnly',
            'runtimeClasspath',
            'default',
        ]
        analyzers {
            assemblyEnabled = false
        }
        suppressionFile = file("${rootDir}/repose-aggregator/src/config/dependency-check/OWASP-Suppression.xml")

        // Configures the dependencyCheck plugin to fail the build if any vulnerability is found
        failBuildOnCVSS = 0
    }

    jar {
        manifest {
            attributes(
                    "Specification-Title": "Repose Components - $project.name",
                    "Specification-Vendor": "Rackspace US, Inc.",
                    "Specification-Version": version,
                    "Implementation-Title": "Repose Components - $project.name",
                    "Implementation-Version": version,
                    "Implementation-Vendor": "Rackspace US, Inc.",
                    "Implementation-Vendor-Id": project.group,
                    "Built-By": System.getProperty('user.name'),
                    "Build-Jdk": org.gradle.internal.jvm.Jvm.current(),
                    "Created-By": "Gradle $project.gradle.gradleVersion",
            )
        }
        from files([sourceSets.generated.java.outputDir])
    }

    idea {
        module {
            sourceDirs += file("$generatedDir")
            generatedSourceDirs += file("$generatedDir")
        }
    }

    publishing {
        repositories {
            maven {
                name 'reposeNexus'
                if (project.hasProperty('release')) {
                    url 'https://maven.research.rackspacecloud.com/content/repositories/releases'
                } else {
                    url 'https://maven.research.rackspacecloud.com/content/repositories/snapshots'
                }
                credentials {
                    username project.hasProperty('maven.repo.username') ? property('maven.repo.username') : 'Need to provide an actual username'
                    password project.hasProperty('maven.repo.password') ? property('maven.repo.password') : 'Need to provide an actual password'
                }
            }
        }

        publications {
            nebula(MavenPublication) {
                if(project.hasProperty('release')) {
                    signArchives.signatures.findAll({!it.toSign.canonicalPath.contains("deb") && !it.toSign.canonicalPath.contains("rpm")}).each {
                        artifact source: it, extension: 'asc'
                    }
                }

                //when we include the signature it tries to switch the packaging in the pom to pom,
                // i just remove it here, because the default in maven is jar if you don't specify,
                // so i can go fix it only where it needs it
                pom.withXml { XmlProvider xml ->
                    def root = xml.asNode()
                    root.get("packaging").each { root.remove(it) }
                }
            }
        }
    }

    signing {
        required { gradle.taskGraph.hasTask("publish") }
        sign configurations.archives
    }

    if (project.hasProperty("minCoverageRatio")) {
        def minCoverageRatio = (project.findProperty("minCoverageRatio") ?: "0.75") as double

        // Configure the JaCoCo test coverage verification
        jacocoTestCoverageVerification {
            violationRules {
                rule {
                    limit {
                        minimum = minCoverageRatio
                    }
                }
            }
            afterEvaluate {
                sourceDirectories = files([sourceSets.main.java.srcDirs, sourceSets.generated.java.srcDirs])
                classDirectories = files([sourceSets.main.java.outputDir, sourceSets.generated.java.outputDir])
                classDirectories = files(classDirectories.files.collect { classDirectory ->
                    fileTree(dir: classDirectory, excludes: ['**/ObjectFactory.class'])
                })
            }
        }

        // Configure the Scoverage test coverage verification
        checkScoverage {
            minimumRate = minCoverageRatio
        }

        // Wire in test coverage verification tasks
        //
        // Note: To take advantage of Scoverage aggregation, the check dependency on
        // Scoverage was placed in the repose-aggregator sub-project.
        check.dependsOn jacocoTestCoverageVerification
    }

    buildAll.dependsOn build
    publish.dependsOn buildAll
    project.tasks.getByPath(':release').dependsOn publish
}

dependencyRecommendations {
    propertiesFile file: file('versions.properties')
}

//this will let us access the a couple of the versions while still keeping a single source of truth
project.ext.versionProperties = new Properties()
project.ext.versionProperties.load(new FileInputStream("$rootDir/versions.properties"))
